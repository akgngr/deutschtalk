
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Users: Can read their own profile, create if not exists, update own profile.
    match /users/{userId} {
      allow read: if request.auth != null && request.auth.uid == userId;
      allow create: if request.auth != null && request.auth.uid == userId;
      allow update: if request.auth != null && request.auth.uid == userId && request.resource.data.uid == userId;
      allow delete: if false; // Or specific conditions like admin role

      // FCM Tokens: Users can manage their own tokens
      match /tokens/{tokenId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
    }

    // Matchmaking Queue: Authenticated users can add/remove themselves.
    match /matchmakingQueue/{userId} {
      allow read: if request.auth != null;
      allow create, delete: if request.auth != null && request.auth.uid == userId;
      allow update: if false; // Queue entries are typically created/deleted, not updated
    }

    // Matches: Participants can read. Creation/update should be handled by secure server-side logic.
    match /matches/{matchId} {
      allow read: if request.auth != null && request.auth.uid in resource.data.participants;
      // Writes (create, update, delete) should ideally be handled by Cloud Functions or Server Actions
      // with proper validation to ensure only matched users or system can modify.
      // For simplicity, restricting direct client writes for now unless through validated server actions.
      allow create: if request.auth != null && request.auth.uid in request.resource.data.participants; // Allow if creating user is a participant
      allow update: if request.auth != null && request.auth.uid in resource.data.participants; // Allow if updating user is a participant
      allow delete: if false; // Or specific conditions

      // Messages: Participants can read and create. SenderId must match auth.uid.
      match /messages/{messageId} {
        function isParticipant(matchDoc) {
          return request.auth.uid in matchDoc.data.participants;
        }
        function isValidMessage(message) {
          return message.senderId == request.auth.uid &&
                 message.text != null && message.text.size() > 0 && message.text.size() < 1024 && // Basic length check
                 message.timestamp == request.time; // Ensure timestamp is server time
        }

        allow read: if request.auth != null && isParticipant(get(/databases/$(database)/documents/matches/$(matchId)));
        allow create: if request.auth != null && isParticipant(get(/databases/$(database)/documents/matches/$(matchId))) && isValidMessage(request.resource.data);
        allow update, delete: if false; // Restrict updates/deletes for simplicity, or add sender-only conditions
      }
    }
  }
}
